
# XBIOS for PC-8001mkIIについて

## 概要
XBIOS for PC-8001mkIIは、SLANGクロスコンパイラにおいてメモリ64kBの空間を出来るだけ多く使うために作られたX1風味のBIOSサブセットです。

PC-8001mkIIは起動時はメモリの上部(0000H～7FFFH)がROM領域になっており、更にグラフィックを使う場合はVRAM領域として使われる8000H～BFFFHも使いづらいため、大きなプログラムを作るにはメモリのやりくりが大変でした。

そこで、XBIOS環境においては、メインプログラムをC000Hから配置した上で、ROM部を使わず、64kBを全てRAMにした上で、XBIOSを0000Hから配置し、比較的余裕のあるメモリ空間を実現します。

XBIOSには文字の表示や入力関連の処理のみが含まれ、本来のROMに含まれる機能の大部分は提供されませんが、そのぶん容量的には軽くなっています。

とはいえ、メインプログラムがC000Hから配置され、なおかつF300HからはテキストVRAMがあり、XBIOS環境ではF200H～F2FFHもスタックになっているので、普通の作り方では結構キビしめになります。そこで、プログラムやデータを1000H～BFFFHの任意の場所に置くような小細工をする方法について、別途[モジュールの使い方](#モジュールの使い方)にて解説します。

また、XBIOSは元々はPC-8001/8801用のOS「S-OS」に含まれていたものを大雑把にカラー対応させたものとなっており、SHARP X1風のBIOSコールと、S-OS風のルーチンを大雑把に混ぜたようなものになっています。

## メモリ空間
SLANGクロスコンパイラでXBIOSを使ったプログラムをコンパイルした時のメモリ空間は下記のようになっています。

```
0000H～0FFFH : XBIOS本体
1000H～BFFFH : (フリー)
C000H～F1FFH : メインプログラム
F200H～F2FFH : スタック
F300H～FEB7H : テキストVRAM
```

(ワーク)
```
FF00H: PORT 30Hに書き込まれている値
```

メインプログラムはC000Hから始まり、起動直後にXBIOS本体をカセットまたはSDカードから読み込み、上記の領域に配置します。

配置後、XBIOSのエントリである0000Hが呼び出され、初期化後にメインプログラム領域に戻ってきます。

以降は、64kBの空間内を自由に使ってプログラムを動かす事が出来ます。

また、PORT30Hについてはメインプログラム側でも使う事があると思いますが、その場合は上記ワークからPORT30Hの値を拾った後、書き換える必要がある部分のみ書き換えてからポートに書き、あわせて、ワークに書き戻すようにしてください。


## カセット環境での使い方
このフォルダに同梱されているXBIOS.CMTを、SLANGクロスコンパイラで生成された(自作プログラムの出力結果である)CMTファイルと連結してください。

### 例
```
COPY /B PROG.CMT+XBIOS.CMT GAME.CMT
```

これにより、PROG.CMTのプログラムが読み込まれ、実行開始時に、自動的にXBIOS.CMTがメモリ(0000H～)に読み込まれ、動作します。


## SDカード環境での使い方
SDカード環境でXBIOSを動かす場合は、SLANGのソースコードの冒頭で、下記の定義をしてください。

```
CONST ASM PC8001_SD = 1;
```

この定義により、SDカード環境用にコンパイルが行われます。

コンパイルが終わったら、出力されたメインプログラムのバイナリ(例えばPROG.CMT)と、このフォルダに同梱されているXBIOS.CMTを、SDカード内に格納してください(エミュレータの場合はSDフォルダに入れてください)。

それにより、PROG.CMTを読み込み、実行後に、自動的にSDカードからXBIOS.CMTがメモリ(0000H～)に読み込まれ、動作します。

## FDD環境の場合
未サポートです


## モジュールの使い方
通常の実装においては、メインプログラムはC000H～F1FFHのみに配置され、せっかくの広大な1000H～BFFFHの空間にはプログラムを置けません。

しかし、SLANGクロスコンパイラには、任意の場所にプログラムを配置する仕組みがあります。

### モジュールの定義

まずは、SLANGのソースコードで「モジュール」部を定義し、そこにプログラムを記述します。

(例)
```

// これを定義するとSDカード環境になり、定義しないとカセット環境になる
//CONST ASM PC8001_SD = 1;

#MODULE $1000

MODULEPROC()
{
    PRINT("This is module!",/);
}

#END

MAIN()
{
#IF PC8001_SD==1
  // for SD
  SD_ROPEN("MODTESTM0.CMT");
  SD_RREAD();
#ELSE
  // for CMT
  LOADCMT();
#ENDIF

    MODULEPROC();
}

```

このプログラムは、プログラム開始時にメモリの1000Hからモジュール「MODTESTM0.CMT」を読み込んで、関数「MODULEPROC()」を配置して、それをメイン部から呼び出す例です。

これをSLANGクロスコンパイラでコンパイルすると、モジュール分割に対応したバイナリファイルが出力されます(出力オプションとして、 -bin -sym を指定してください)。

モジュール分割に対応したバイナリは、ツール「ModuleSplitter」でモジュールとメイン部を分割出来る状態になっているので、例えば、

```
ModuleSplitter MODTEST --cmt
```

のように実行する事で、MODTEST.binと、MODTEST.symを読み込み、適切にモジュールを分割し、--cmtオプションにより、CMTファイルが出力されます。

このプログラムが「MODTEST.SL」という名前だった場合、出力されるのは下記の2ファイルです(この他にもバイナリファイルなどが出力されますが、使われません)。

* MODTESTMAIN.CMT
* MODTESTM0.CMT

カセット環境の場合は、このCMTファイルを、

```
COPY /B MODTESTMAIN.CMT+XBIOS.CMT+MODTESTM0.CMT MODTEST.CMT
```

のように連結する事で、実行可能なCMTファイルが作成出来るので、これをモニタからロードしてください。

SDカード環境の場合は、各CMTファイル(と、XBIOS.CMT)をSDカードにコピーした後、MODTESTMAIN.CMTをロードします。

このあと、```G C000```で実行する事により、XBIOSが読み込まれて起動し、MAIN関数の冒頭に記載されたカセットまたはSDからの読み込み処理によりモジュールが読み込まれ、適切なアドレスにモジュールが配置される事で、MODULEPROC()関数を正常に呼び出す事が可能になります。

かなりややこしいですが、この方法でプログラムの他、データの読み込みなども可能なので、かなり自由にメモリ空間を活用可能になっています。


## XBIOSコール一覧
通常は、XBIOSのコールはSLANGクロスコンパイラのライブラリから使われるだけなので、意識する必要は無いのですが、アセンブラなどで直接使う可能性も無くもないので、存在するルーチンについてまとめておきます。


### 0000H START コールドブート
XBIOSコールドブートエントリです。XBIOSを初期化し、利用可能な状態にします。

SLANGクロスコンパイラ版は、メインプログラムからこのエントリがCALLされ、初期化後に呼び出し元に戻ります。

(ソースコードXBIOSMAIN.ASM を確認いただくとわかるとおり、SYSTEMにメインプログラムアドレスを定義すると、CALLではなく JP 0000H で飛んでくる想定で、初期化後にSYSTEMにジャンプするような挙動になります。通常はSYSTEMは未定義で良いと思います)。

### 0003H INPUT 一行入力
DEレジスタに格納アドレスを入れて呼び出すと、一行入力して戻ります。

STOPキーなどで文字入力を中断した場合、1文字目に 1BH が入ります。

また、格納アドレスの先は256バイトの領域が必要になります(呼び出した直後に全て0で埋められます)。

### 000BH PRINTS 文字列の表示
DEに文字列のアドレスを入れて呼び出すと、文字列を表示します。
文字列の末尾には 0 を入れてください。

### 0013H PUTC 一文字表示
Aレジスタに入った文字を表示します。

### 001BH _INKEY 
Aレジスタに0を入れて呼ぶとリアルタイムキー入力をし、入力文字をAに返します。入力していない場合は0が返ります。
Aレジスタに1を入れて呼ぶとカーソルを表示し、1文字入力をし、入力文字をAに返します。
Aレジスタに0、1以外を入れて呼ぶとカーソルを表示せずに1文字入力をし、入力文字をAに返します。

いずれも入力文字は画面に表示されません。

### 004AH BRKEY STOPキーチェック
STOPキーが押された場合はZフラグが立ち、押されていない場合はZフラグが寝ます。

### 004DH WIDCH 画面横幅設定
Aレジスタに40または80を入れるとその文字数で画面の横幅を設定します。

### 0050H ADRC2 VRAMアドレス計算
BレジスタにY、CレジスタにXのテキスト位置を入れてから呼び出すと、HLにVRAMアドレスを返します。

### 0053H LPOUT プリンタ出力
Aレジスタの文字をプリンタに出力します。

### 005FH LOCATE カーソル位置指定
BにY位置、CにX位置を入れて呼び出すとカーソルの位置を設定します。

### 0062H SETATR テキストアトリビュート設定
BにY(0～24)、CにX(0-79)、Aに新規適用するアトリビュートを入れて呼び出すと、テキストアトリビュートを設定します。
Xを $80 にして呼び出すと該当行を初期化します。

同一行に20以上の設定をした場合は最後尾のアトリビュートが上書きされます。

### 0065H LPTON プリンタ出力有効指定
006EH PRINTでの文字出力時に同時にプリンタにも文字を出力するよう指定します。

### 0068H LPTOF プリンタ出力無効指定
006EH PRINTでの文字出力時に同時にプリンタにも文字を出力しないよう指定します。

### 006BH LPRNT プリンタ出力2
プリンタにAレジスタの文字を出力します。

LPOUTとの違いは、プリンタ出力エラーが発生した場合、自動的にプリンタ出力が無効になる点です。

### 006EH PRINT 文字列出力
Aレジスタの文字を表示します。

LPON呼び出し後に実行すると、同時にプリンタにも出力されます。

### 0071H SCRN 画面文字取得
HにY座標、LにX座標をセットしコールすると、画面上の同位置にある文字をAレジスタに入れて返します。

### 0074H GETKY リアルタイムキー入力
キーボードからリアルタイム入力します。

Aレジスタに0を入れて_INKEYを呼び出すのと同じですが、STOPキーを押すと1BHが返ります。

### 0077H FLGET 一文字入力
カーソルを表示して一文字入力し、入力された文字をAに返します。

Aレジスタに1を入れて_INKEYを呼び出すのと同じですが、STOPキーを押すと1BHが返ります。

### 007AH INKEY 一文字入力
カーソルを表示せずに一文字入力し、入力された文字をAに返します。

Aレジスタに0か1以外を入れて_INKEYを呼び出すのと同じですが、STOPキーを押すと1BHが返ります。

### 007DH CSR カーソル位置取得
現在のカーソル位置をHにY座標、LにX座標を読み出します。

### 0080H HLHEX 16進数文字列変換
DEレジスタで示されるアドレスから4文字ぶんを4桁の16進数として変換し、HLに格納して返します。

### 0085H GETL 一行入力
DEレジスタにキー入力バッファの先頭アドレスを入れてコールするとキーボードから一行入力を行い、文字列を格納し、末尾に0を入れて返します。途中でSTOPキーが押された場合は先頭に1BHが入ります。

## XBIOSワーク一覧
### 0007H (1byte) WIDTH 横幅
40か80のどちらかが入っています。

### 0027H (1byte) NULCHR 空白文字
画面クリアなどで使われる空白文字が入ります。

ここに任意の文字を入れておくと、画面クリア時は設定した文字で画面が埋められます。

### 0083H (2bytes) KBFAD キー入力バッファアドレス
256バイトのキー入力用バッファへのアドレスです。

SLANGクロスコンパイラの文字列入力などで使われますが、汎用的に使っても問題ありません。



### アセンブラから使うためのEQU定義(参考)

```
XBIOS:
.INPUT  equ $0003
.PRINTS equ $000B
.PUTC   equ $0013
.WIDCH  equ $004D
.LOCATE equ $005f
.SETATR equ $0062
.LPTON  equ $0065
.LPTOF  equ $0068
.LPRNT  equ $006B
.PRINT  equ $006E
.SCRN   equ $0071
.GETKY  equ $0074
.FLGET  equ $0077
.INKEY  equ $007A
.CSR    equ $007D
.HLHEX  equ $0080  
.KBFAD  equ $0083
.GETL   equ $0085
.PORT30 equ $FF00
.PORT31 equ $FF01
.PORT40 equ $FF02
```




## XBIOSの制限

* カラーモードのみ対応です(一応 ```COLOR_MODE EQU 0``` を定義する事で白黒モード対応でビルド出来ますが、未確認です)
* 元々の白黒版では行の連結を考慮した文字削除処理や、文字入力処理が実装されていましたが、カラー化に伴い実装がややこしかったので、それらの処理は行の連結を考慮しないよう書き換えてあります(どなたか、ちゃんと行がつながるよう書き換えてくれると嬉しいです……)
* 全体的に検証が甘いのであちこち変だと思います
* 98%くらいはS-OSで使われていた時のままですので、権利のほとんどはオリジナルの作者様に帰属します
* 無保証です
